# 序
shell是用户与Linux或Unix内核通信的工具,shell编程指的并不是编写这个工具,而是指利用现有的shell工具进行编程,写出来的程序是轻量级的脚本,我们叫做shell脚本。

shell的语法是从C语言继承过来的,因此我们在写shell脚本的时候,无论从语法、语意还是书写格式上往往能看到C语言的影子。

shell脚本实在是太灵活了,相比标准的Java、C、C++ 等，它不过是一些现有命令的堆叠,这是他的优势也是他的劣势,太灵活导致不容易写规范。本人在写shell脚本的过程中形成了一些自己的规范,这些规范还在实践中,在此分享出来,以期更多的人来帮助我完善。
当然也希望随着规约的不断update,有朝一日能成为业界的规范。

linux提供了很多强大到令人窒息的命令,虽然美好,但好多时候我们使用起来还要man一下,或者不停的调试修改参数直到达到我们想要的结果。另外linux对数据结构支持的并不友好,我们很少在shell中使用过像map、list、tree、queue这样的数据结构,我们也很少使用shell去直接操作数据库、缓存,我们更不能像Java一样使用线程池等等,不这样做的原因一方面是shell并不适合处理这些问题(是不适合,并不是不能),另一方面是并不像Java、C、C++等语言一样有丰富的工具类。所以催生出了我想写BaseShell项目的想法

BaseShell是一个函数集,旨在提供丰富的像Java语言一样的框架,可以理解为shell版的jar包。我在这里面实现了类似Java风格的 线程池(其实是进程池)、map数据结构、list数据结构、阻塞队列、锁、日志框架等工具。

![](!http://piyoxv26o.bkt.clouddn.com/BaseShellJietu20181129-232543@2x.jpg)

# 关于并发
谈到并发,我们优先想到的就是多线程。线程是进程内的最小运行单元,进程是系统的最小运行单元。所以线程是比进程更细粒度的调度工具。一个进程可以理解为一个应用、一个软件、一个脚本执行,这些应用、软件、脚本共享系统的资源如 磁盘、网络、内存。一个线程只能共享一个应用内的资源。

Shell中并没有真正意义的多线程,要实现多线程可以启动多个后端进程,最大程度利用cpu性能。

在 BaseShell 中 BaseShell/Concurrent 目录下,有我提供的关于线程池的工具

第一步 创建一个线程池
第二步 想线程池中提交任务

# 关于命名
1. 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。
  反例：_name / __name / $Object / name_ / name$ / Object$
  因为$往往作为Shell中的取值运算符,$出现在变量中容易引起歧义 $Object 代表取变量Object的值呢,还是定义一个变量名叫$Object呢

2. 【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。
 说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。
 正例：alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。
 反例：DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3
 虽然支持中文变量,但容易引起歧义,因为我们的日志输出中往往使用中文,如果使用中文变量给人很凌乱的感觉

变量名、函数名
尽量不适用全局变量
说明: 我们都知道全局变量,可以在任何使用的地方被修改,但没有人清楚,改变之后是否会影响到其他正在调用的地方。



3. 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。
 正例：MAX_STOCK_COUNT
 反例：MAX_COUNT



# 关于首行
# 关于函数
# 关于赋值
# 关于换行
# 关于注释
# 关于变量
# 关于计算
# 关于文件
# 关于分支
# 关于Test表达式
# 单元测试
# 调试技术


> 只能有一级目录

> controller之间不能互相调用

> 引入 BaseEnd.sh 的脚本不能被其他引入 BaseEnd.sh的脚本引用

>引入 Header的目的是为了引入静态常量

# 函数返回值
function 定义的函数类似公共函数

shell 中用0代表真 ，非零代表假
目的是0代表这个正常，其他代表异常，123各自有各自的异常


return 的直接
$(functionName) && balabla || balabala
不用 [[$(functionName)]]


有名管道 创建出来 关联文件描述符 ，进程退出文件描述符作废


eval "exec ${FD}<>${threadPoolName} && rm -rf ${threadPoolName}"

eval 可以将 一个字符串命令来执行

{1..10}左闭右闭


多线程控制的几种方式

1. 最多有100个线程并发执行,当有第101个任务提交的时候,阻塞
2. 最多有100个线程并发执行,有多少个任务就提交多少个任务,但是后台一次只有100个线程取出来并发执行,执行完成后再去任务队列中取一个
3. 最多有100个线程并发执行,有多少提交多少,发现执行完成了就在通知执行一个或一批


关于使用 fifo + 文件描述符进行了两种尝试，一种是惰性加载，但是失败了，但是不能实现线程池之间的并发执行

ulimit = user limit 该命令也就是用户限制，限制了最大调用的进程数和文件描述符的大小。

Header 防止重复引用，其他的也可以这么用，为了简单，不想jav还有编译器


END只能放到最后






$LINENO 打印行号

list=($(new_arrayList "1 2 3"))
echo ${list[*]}

list_size "${list[*]}"
list=($(list_add ${list[*]} 1 2 3 45 66))

数组要用()接收

[[ -z $1 ]] && log_fail "${err_msg}" 作为最后一行会改变返回值的状态

return 形式的返回不适用 [[]]

exec 1024<>token 关联fd后写编程了非阻塞的了
timeunit sleep
定时任务

log_info eval $(gdate) 传递，会先计算，而不是延迟计算
